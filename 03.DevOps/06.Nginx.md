---
title: Nginx 完全指南：从原理到实战
date: 2025-12-15
author: Eugen
tags:
  - Nginx
  - Web服务器
  - 反向代理
  - 负载均衡
  - DevOps
  - 运维工具
---

# 🚀 Nginx 完全指南：从原理到实战

> Nginx（发音 "Engine X"）是互联网世界的**流量枢纽**。你刷的抖音、看的B站、逛的淘宝，背后都有它在默默转发请求。本文将用通俗的语言配合硬核的配置，带你彻底拿下 Nginx。

---

## 一、🐣 它是谁？为什么要用它？

### 1.1 核心角色：火锅店的"超级前台"

想象你开了一家超级火爆的火锅店（**后端服务器**），如果顾客直接冲进厨房找厨师（Tomcat/Node.js）点菜，厨房一定乱成一锅粥。

这时候，你雇佣了 **Nginx** 站在大门口：

| 角色 | 职责 | 技术对应 |
|:---|:---|:---|
| 🛡️ **保镖** | 顾客只认识前台，不知道厨房后门在哪 | 反向代理（Reverse Proxy） |
| 📋 **调度员** | A厨师忙疯了，把新订单递给摸鱼的B厨师 | 负载均衡（Load Balancing） |
| 🧊 **效率专家** | 顾客要瓶可乐，直接从前台冰柜拿，不麻烦厨师 | 动静分离（Static/Dynamic Separation） |

### 1.2 为什么 Nginx 这么快？

Nginx 采用**事件驱动的异步非阻塞架构**，核心技术是 **多路复用（Epoll）**：

- **传统服务器（Apache）**：来一个客人派一个服务员盯着，人多了服务员不够用 → 进程/线程模型
- **Nginx**：一个服务员盯着全场，谁举手就处理谁，处理完立刻盯下一个 → 事件驱动模型

> 💡 **一句话总结**：就在你眨眼的一瞬间，Nginx 能处理上万个并发连接，同时内存占用极低。

### 1.3 主要应用场景

1. **Web服务器**：直接提供 HTTP 服务
2. **反向代理**：隐藏后端服务器，提供统一入口
3. **负载均衡**：分发请求到多个后端服务器
4. **静态资源服务**：高效处理图片、CSS、JS 等静态文件
5. **API网关**：微服务架构的统一入口
6. **SSL终端**：处理 HTTPS 加密和解密
7. **TCP/UDP代理**：数据库、Redis 等四层转发

---

## 二、🏗️ 安装 Nginx

### 2.1 包管理器安装（推荐新手）

```bash
# Ubuntu/Debian
sudo apt update && sudo apt install -y nginx
sudo systemctl start nginx && sudo systemctl enable nginx

# CentOS/RHEL
sudo yum install -y epel-release && sudo yum install -y nginx
sudo systemctl start nginx && sudo systemctl enable nginx
```

### 2.2 源码编译安装（需要自定义模块时）

当你需要添加第三方模块（如 Brotli 压缩、缓存清理模块）时，必须从源码编译：

```bash
# 1. 安装编译依赖
sudo apt install -y build-essential libpcre3 libpcre3-dev zlib1g zlib1g-dev libssl-dev

# 2. 下载并解压源码
wget http://nginx.org/download/nginx-1.24.0.tar.gz
tar -xzf nginx-1.24.0.tar.gz && cd nginx-1.24.0

# 3. 配置编译选项（关键步骤）
./configure \
    --prefix=/usr/local/nginx \
    --with-http_ssl_module \          # HTTPS 支持
    --with-stream \                   # TCP/UDP 四层转发
    --with-http_stub_status_module \  # 状态监控页面
    --add-module=/path/to/module      # 添加第三方模块

# 4. 编译并安装
make && sudo make install
```

> 🛑 **编译报错？** 通常是第1步的依赖库没装好，仔细检查报错信息。

---

## 三、📁 配置文件结构：洋葱式层级

Nginx 配置文件（通常在 `/etc/nginx/nginx.conf`）结构严谨，像洋葱一样一层包一层。

### 3.1 全局结构图解

```nginx
# ==================== 1. Main 全局块 ====================
user nginx;                    # 运行身份
worker_processes auto;         # 工作进程数，建议设为 CPU 核数
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

# ==================== 2. Events 块 ====================
events {
    worker_connections 1024;   # 每个进程最大连接数
    use epoll;                 # Linux 系统推荐
}

# ==================== 3. HTTP 块（七层） ====================
http {
    include mime.types;
    default_type application/octet-stream;

    # 日志格式定义
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent"';

    # 性能优化
    sendfile on;
    keepalive_timeout 65;
    gzip on;

    # 💡 最佳实践：模块化管理，不要把所有配置塞在一个文件里
    include /etc/nginx/conf.d/*.conf;

    # Server 块定义具体网站
    server {
        listen 80;
        server_name example.com;
        # ...
    }
}

# ==================== 4. Stream 块（四层） ====================
# ⚠️ 注意：它和 http 块是平级的！不要写到 http 里面！
stream {
    # TCP/UDP 转发配置
}
```

> 🛑 **小白常见坑**：在 `conf.d/my_site.conf` 里，**不要**再写 `http { ... }` 包裹 `server`！因为主配置已经有了 `http`，`include` 只是把内容"吸入"进去，再写一遍会报嵌套错误。

### 3.2 配置文件管理最佳实践

```
/etc/nginx/
├── nginx.conf              # 主配置文件
├── mime.types              # MIME 类型定义
├── conf.d/                 # 通用配置
│   ├── gzip.conf           # 压缩配置
│   ├── proxy.conf          # 代理通用配置
│   └── security.conf       # 安全头配置
├── sites-available/        # 所有站点配置
│   ├── api.example.com.conf
│   └── www.example.com.conf
└── sites-enabled/          # 已启用站点（符号链接）
    └── api.example.com.conf -> ../sites-available/api.example.com.conf
```

```bash
# 启用/禁用站点
sudo ln -s /etc/nginx/sites-available/mysite.conf /etc/nginx/sites-enabled/
sudo rm /etc/nginx/sites-enabled/mysite.conf

# 测试并重载配置
sudo nginx -t && sudo nginx -s reload
```

---

## 四、🎯 Location 匹配规则（必考题）

这是 Nginx 最让人头秃的地方。请死记硬背以下口诀：

> 🎯 **"精确最贵，前缀锁定随后，正则看顺序，普通前缀是备胎。"**

### 4.1 匹配符号优先级

| 优先级 | 符号 | 名称 | 说明 |
|:---:|:---|:---|:---|
| 1️⃣ | `=` | 精确匹配 | 完全一模一样才行，匹配后立即停止 |
| 2️⃣ | `^~` | 前缀锁定 | 匹配上这个前缀，就**不再看正则** |
| 3️⃣ | `~` / `~*` | 正则匹配 | `~` 区分大小写，`~*` 不区分 |
| 4️⃣ | `/xxx` | 普通前缀 | 所有都匹配不上时的兜底 |

### 4.2 实战案例分析

```nginx
location = /images/logo.png { return 200 "A: 精确"; }
location ^~ /images/        { return 200 "B: 前缀锁定"; }
location ~ /images/.*\.png$ { return 200 "C: 正则"; }
location /images/           { return 200 "D: 普通前缀"; }
```

| 请求路径 | 命中 | 原因 |
|:---|:---:|:---|
| `/images/logo.png` | A | `=` 精确匹配，优先级最高，直接结束 |
| `/images/avatar.png` | B | 满足 B 的 `^~` 前缀锁定，**忽略** C 正则 |
| `/images/test.jpg` | B | 同上，`^~` 阻止了正则匹配 |

如果把 B 改成普通前缀（去掉 `^~`）：

```nginx
location /images/ { return 200 "B: 普通前缀"; }
```

| 请求路径 | 命中 | 原因 |
|:---|:---:|:---|
| `/images/avatar.png` | C | B 是普通前缀，存为"备胎"；C 正则匹配成功，正则优先 |

### 4.3 动静分离标准写法

```nginx
server {
    listen 80;
    server_name example.com;

    # 1. 静态文件优先处理（正则匹配）
    location ~ .*\.(gif|jpg|jpeg|png|css|js|ico)$ {
        root /var/www/static;
        expires 30d;  # 客户端缓存30天
        add_header Cache-Control "public, immutable";
    }

    # 2. 其他请求转发给后端
    location / {
        proxy_pass http://backend_server;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

---

## 五、⚖️ 负载均衡详解

当你有两台以上服务器时，Nginx 的魔力就体现出来了。通过 `upstream` 模块定义后端服务器组。

### 5.1 四种负载均衡策略

```nginx
# 策略1：轮询（默认）- 绝对公平，依次分配
upstream backend {
    server 192.168.1.101:8080;
    server 192.168.1.102:8080;
}

# 策略2：加权轮询 - 能者多劳
upstream backend {
    server 192.168.1.101:8080 weight=1;  # 旧服务器，接1个
    server 192.168.1.102:8080 weight=5;  # 新服务器，接5个
}

# 策略3：IP Hash - 会话保持
# 同一IP永远分给同一台机器，解决 session 不共享问题
upstream backend {
    ip_hash;
    server 192.168.1.101:8080;
    server 192.168.1.102:8080;
}

# 策略4：最少连接 - 优先分给最闲的
upstream backend {
    least_conn;
    server 192.168.1.101:8080;
    server 192.168.1.102:8080;
}
```

### 5.2 健康检查与故障转移

```nginx
upstream backend {
    server 192.168.1.101:8080 max_fails=3 fail_timeout=30s;  # 失败3次后，30秒内不再分配
    server 192.168.1.102:8080 max_fails=3 fail_timeout=30s;
    server 192.168.1.103:8080 backup;  # 🚑 备用服务器，只有上面都挂了才启用
    server 192.168.1.104:8080 down;    # 🔴 标记下线，不参与分配
}
```

### 5.3 完整反向代理配置

```nginx
upstream backend_api {
    least_conn;
    server 192.168.1.10:8080 weight=3 max_fails=3 fail_timeout=30s;
    server 192.168.1.11:8080 weight=2 max_fails=3 fail_timeout=30s;
    server 192.168.1.12:8080 backup;
}

server {
    listen 80;
    server_name api.example.com;

    location / {
        proxy_pass http://backend_api;

        # 必要的代理头设置
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # 超时设置
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;

        # 缓冲设置
        proxy_buffering on;
        proxy_buffer_size 4k;
        proxy_buffers 8 4k;
    }
}
```

---

## 六、🌐 四层 vs 七层代理

很多人搞不清 Nginx 能不能转发数据库或 TCP 连接，答案是：**能，但配置位置不同**。

### 6.1 核心区别

| 维度 | Layer 7（应用层） | Layer 4（传输层） |
|:---|:---|:---|
| **处理对象** | HTTP 内容（URL、Header、Cookie） | TCP/UDP 数据包（IP + 端口） |
| **智能程度** | 高（能看懂 `/api` 还是 `/img`） | 低（只负责搬运数据流） |
| **性能** | 稍慢（要拆包看内容） | 极快（直接转发） |
| **配置块** | `http { ... }` | `stream { ... }` |
| **适用场景** | Web应用、API服务 | MySQL、Redis、自定义TCP协议 |

### 6.2 七层代理示例（HTTP）

```nginx
http {
    server {
        listen 80;
        server_name api.example.com;

        location / {
            proxy_pass http://127.0.0.1:3000;  # 转发给 Node.js
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }
    }
}
```

### 6.3 四层代理示例（TCP/UDP）

```nginx
# ⚠️ stream 块必须和 http 块平级！
stream {
    # 日志格式（四层专用）
    log_format tcp_log '$remote_addr [$time_local] $protocol $status '
                       '$bytes_sent $bytes_received $session_time';
    access_log /var/log/nginx/stream.access.log tcp_log;

    # MySQL 负载均衡
    upstream mysql_cluster {
        least_conn;
        server 192.168.1.10:3306;
        server 192.168.1.11:3306;
    }

    server {
        listen 3306;              # Nginx 监听 3306
        proxy_pass mysql_cluster; # 转发给内网数据库
        proxy_connect_timeout 1s;
        proxy_timeout 3s;
    }

    # Redis 转发（使用 IP Hash 保持连接一致性）
    upstream redis_cluster {
        hash $remote_addr consistent;
        server 192.168.1.20:6379;
        server 192.168.1.21:6379;
    }

    server {
        listen 6379;
        proxy_pass redis_cluster;
    }

    # UDP 转发示例（DNS）
    upstream dns_servers {
        server 8.8.8.8:53;
        server 8.8.4.4:53;
    }

    server {
        listen 53 udp;
        proxy_pass dns_servers;
        proxy_timeout 1s;
        proxy_responses 1;
    }
}
```

### 6.4 SSL/TLS 处理

```nginx
# 七层 HTTPS 终止（Nginx 解密，后端走 HTTP）
server {
    listen 443 ssl http2;
    server_name example.com;

    ssl_certificate /etc/nginx/ssl/example.com.crt;
    ssl_certificate_key /etc/nginx/ssl/example.com.key;
    ssl_protocols TLSv1.2 TLSv1.3;

    location / {
        proxy_pass http://backend;  # 后端不需要处理 SSL
        proxy_set_header X-Forwarded-Proto https;
    }
}

# HTTP 自动跳转 HTTPS
server {
    listen 80;
    server_name example.com;
    return 301 https://$server_name$request_uri;
}
```

---

## 七、📝 日志配置

### 7.1 常用日志变量

| 变量 | 说明 |
|:---|:---|
| `$remote_addr` | 客户端 IP |
| `$time_local` | 本地时间 |
| `$request` | 完整请求行 |
| `$status` | 响应状态码 |
| `$body_bytes_sent` | 响应体大小 |
| `$request_time` | 请求处理时间（秒） |
| `$upstream_response_time` | 后端响应时间 |
| `$http_user_agent` | 客户端 User-Agent |

### 7.2 自定义日志格式

```nginx
http {
    # 标准格式
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent"';

    # 详细格式（包含性能指标）
    log_format detailed '$remote_addr [$time_local] "$request" '
                        '$status rt=$request_time '
                        'uct="$upstream_connect_time" '
                        'urt="$upstream_response_time"';

    # JSON 格式（便于 ELK 等日志系统解析）
    log_format json escape=json '{'
        '"time":"$time_iso8601",'
        '"remote_addr":"$remote_addr",'
        '"request":"$request",'
        '"status":$status,'
        '"request_time":$request_time,'
        '"upstream_response_time":"$upstream_response_time"'
    '}';

    server {
        access_log /var/log/nginx/access.log main;
        # 或使用 JSON 格式
        # access_log /var/log/nginx/access.json json;
    }
}
```

### 7.3 条件日志（只记录慢请求）

```nginx
# 只记录处理时间 > 1秒的请求
map $request_time $loggable {
    ~^[0]\.[0-9]+$ 0;  # 小于1秒不记录
    default 1;
}

access_log /var/log/nginx/slow.log detailed if=$loggable;
```

---

## 八、⚡ 性能优化配置

```nginx
# 全局优化
user nginx;
worker_processes auto;              # 自动匹配 CPU 核数
worker_rlimit_nofile 65535;         # 最大文件描述符数

events {
    worker_connections 4096;        # 每个 worker 最大连接数
    use epoll;                      # Linux 高性能事件模型
    multi_accept on;                # 一次接受多个连接
}

http {
    # 文件传输优化
    sendfile on;                    # 零拷贝传输
    tcp_nopush on;                  # 优化数据包发送
    tcp_nodelay on;                 # 禁用 Nagle 算法

    # 连接优化
    keepalive_timeout 65;
    keepalive_requests 100;         # 每个连接最大请求数

    # 文件缓存
    open_file_cache max=10000 inactive=20s;
    open_file_cache_valid 30s;
    open_file_cache_min_uses 2;

    # Gzip 压缩
    gzip on;
    gzip_vary on;
    gzip_comp_level 6;
    gzip_min_length 1000;
    gzip_types text/plain text/css application/json
               application/javascript text/xml application/xml
               image/svg+xml;

    # 缓冲优化
    client_body_buffer_size 128k;
    client_max_body_size 10m;
    proxy_buffer_size 4k;
    proxy_buffers 8 4k;
}
```

---

## 九、🔒 安全配置

```nginx
http {
    # 隐藏版本号
    server_tokens off;

    # 安全响应头
    add_header X-Frame-Options "SAMEORIGIN" always;          # 防止点击劫持
    add_header X-Content-Type-Options "nosniff" always;      # 防止 MIME 嗅探
    add_header X-XSS-Protection "1; mode=block" always;      # XSS 防护
    add_header Referrer-Policy "no-referrer-when-downgrade"; # Referrer 策略

    # SSL 安全配置
    ssl_protocols TLSv1.2 TLSv1.3;   # 只允许安全协议
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;

    # 限制请求大小
    client_max_body_size 10m;

    # 限制请求方法
    if ($request_method !~ ^(GET|HEAD|POST|PUT|DELETE|OPTIONS)$) {
        return 405;
    }
}
```

---

## 十、📊 状态监控

```nginx
server {
    listen 8080;
    server_name localhost;

    location /nginx_status {
        stub_status on;       # 启用状态模块
        access_log off;       # 不记录访问日志
        allow 127.0.0.1;      # 只允许本机访问
        allow 192.168.1.0/24; # 允许内网访问
        deny all;             # 禁止其他访问
    }
}
```

访问 `http://server:8080/nginx_status` 可以看到：
- Active connections：当前活跃连接数
- Server accepts/handled/requests：总连接数/处理数/请求数
- Reading/Writing/Waiting：读取/写入/等待的连接数

---

## 十一、📜 常用命令速查表

| 命令 | 说明 | 使用场景 |
|:---|:---|:---|
| `nginx -t` | 检查配置语法 | 每次改完配置**必敲** |
| `nginx -T` | 显示完整配置 | 调试时查看最终配置 |
| `nginx -s reload` | 平滑重载配置 | 不中断服务，新配置生效 |
| `nginx -s stop` | 强制停止 | 立即停止所有连接 |
| `nginx -s quit` | 优雅停止 | 处理完当前请求再停止 |
| `nginx -V` | 查看版本和编译参数 | 确认安装了哪些模块 |
| `nginx` | 启动 Nginx | 首次启动 |

```bash
# 常用调试命令
sudo nginx -t                        # 测试配置
sudo nginx -s reload                 # 重载配置
ps aux | grep nginx                  # 查看进程
tail -f /var/log/nginx/error.log     # 实时查看错误日志
tail -f /var/log/nginx/access.log    # 实时查看访问日志
```

---

## 十二、🔧 常见问题排查

### 12.1 配置不生效

```bash
# 1. 检查配置语法
sudo nginx -t

# 2. 确认重载了配置
sudo nginx -s reload

# 3. 检查是否被其他 location 拦截
nginx -T | grep -A 10 "server_name your_domain"
```

### 12.2 502 Bad Gateway

```bash
# 1. 检查后端服务是否运行
curl http://127.0.0.1:8080

# 2. 检查 upstream 配置的地址和端口
# 3. 查看错误日志
tail -f /var/log/nginx/error.log
```

### 12.3 权限问题

```bash
# Nginx 运行用户需要有读取静态文件的权限
sudo chown -R nginx:nginx /var/www/html
sudo chmod -R 755 /var/www/html
```

---

## 十三、🕙 超时时间配置

在 Nginx 中，修改超时时间可以在 **三个层级** 进行配置，具体取决于你希望配置生效的范围。

这三个层级分别是：

1.  **`http` 层级**（全局生效）
2.  **`server` 层级**（特定虚拟主机生效）
3.  **`location` 层级**（特定 URL 路径生效）

优先级规则是：**层级越深，优先级越高**（Location > Server > Http）。如果没有在深层级配置，它会继承上一层级的配置。

---

### 1. 常见的超时参数及其作用

在修改之前，你需要明确你想修改哪种超时时间。最常用的有以下几类：

*   **客户端相关：**
    *   `keepalive_timeout`: 长连接超时时间（最常用）。
    *   `client_header_timeout`: 读取客户端请求头的超时时间。
    *   `client_body_timeout`: 读取客户端请求体的超时时间。
    *   `send_timeout`: 向客户端发送响应的超时时间。

*   **反向代理相关（如果你用 Nginx 做反向代理）：**
    *   `proxy_connect_timeout`: 连接后端服务器的超时时间。
    *   `proxy_read_timeout`: 等待后端服务器响应（读取数据）的超时时间（最常用，解决 504 Gateway Time-out）。
    *   `proxy_send_timeout`: 向后端服务器发送数据的超时时间。

---

### 2. 配置示例

#### 方案 A：在 `http` 层级修改（全局生效）
修改 `nginx.conf` 文件。这会影响该 Nginx 实例下的所有网站。

```nginx
http {
    include       mime.types;
    default_type  application/octet-stream;

    # --- 全局超时设置 ---
    keepalive_timeout  65;
    client_header_timeout 15s;
    client_body_timeout 15s;
    send_timeout 15s;
    
    # 反向代理全局超时
    proxy_connect_timeout 60s;
    proxy_read_timeout 60s;
    proxy_send_timeout 60s;

    server {
        ...
    }
}
```

#### 方案 B：在 `server` 层级修改（针对某个域名）
只对特定的网站（域名）生效，不影响其他网站。

```nginx
server {
    listen       80;
    server_name  example.com;

    # --- 仅对该站点生效 ---
    keepalive_timeout 300; 
    proxy_read_timeout 300; 

    location / {
        root   html;
        index  index.html index.htm;
    }
}
```

#### 方案 C：在 `location` 层级修改（针对特定接口或路径）
这是最精细的控制。例如，你的网站大部分接口很快，但有一个 `/upload` 接口上传文件很慢，或者 `/api/long-task` 需要跑很久，你可以只针对这个路径放宽超时时间。

```nginx
server {
    listen       80;
    server_name  example.com;

    location / {
        # 使用默认或 server 级的配置
        proxy_pass http://backend;
    }

    # --- 仅对 /long-task 路径生效 ---
    location /api/long-task {
        proxy_connect_timeout 600s;
        proxy_read_timeout 600s;  # 允许后端处理 10 分钟
        proxy_send_timeout 600s;
        proxy_pass http://backend;
    }
}
```

### 总结
*   如果所有网站都需要调整，改 **`http`** 层。
*   如果只是某个网站需要调整，改 **`server`** 层。
*   如果是某个具体业务接口报超时（如导出报表、大文件上传），改 **`location`** 层。

**注意：** 修改配置文件后，别忘了测试配置并重载 Nginx：
```bash
nginx -t
nginx -s reload
```

---

## 📚 总结

Nginx 并没有想象中那么可怕：

1. 🏠 把它当成一个**分发请求的前台**
2. 📦 配置文件的核心就是 `http`（Web）和 `stream`（TCP）
3. ⚖️ 搞懂 `upstream` 做负载均衡
4. 🎯 搞懂 `location` 的优先级逻辑（精确 > 前缀锁定 > 正则 > 普通前缀）
5. 🔧 记住 `nginx -t` 和 `nginx -s reload`

掌握这些核心概念和配置，你就能构建高性能、高可用的 Web 服务架构了。

现在，去你的服务器上敲下 `nginx -t`，开始你的表演吧！🎉
