---
title: .NET Core C# 垃圾回收（GC）完全指南
date: 2025-12-15
author: Eugen
tags:
  - .NET Core
  - GC
  - 垃圾回收
  - 内存管理
  - C#
  - 性能优化
  - LOH
---
# 🧹 .NET Core C# 垃圾回收（GC）完全指南

> 本文面向初学者，从基础概念到高级实践，全面介绍 .NET Core 中的垃圾回收机制。

---

## 📚 目录

1. [什么是垃圾回收](#1-什么是垃圾回收)
2. [内存布局：堆与栈](#2-内存布局堆与栈)
3. [托管对象与非托管对象](#3-托管对象与非托管对象)
4. [GC 工作原理](#4-gc-工作原理)
5. [大对象堆（LOH）](#5-大对象堆loh)
6. [固定对象堆（POH）](#6-固定对象堆poh)
7. [终结器（Finalizer）](#7-终结器finalizer)
8. [IDisposable 模式](#8-idisposable-模式)
9. [GC 模式配置](#9-gc-模式配置)
10. [IOC 容器与 GC](#10-ioc-容器与-gc)
11. [最佳实践](#11-最佳实践)
12. [诊断与监控](#12-诊断与监控)

---

## 1. 什么是垃圾回收

### 🤔 为什么需要 GC？

在 C/C++ 时代，程序员需要手动管理内存：

```c
// C 语言手动管理内存
int* ptr = malloc(sizeof(int) * 100);  // 分配
// 使用内存...
free(ptr);  // 必须手动释放，否则内存泄漏！
```

这带来了很多问题：
- 😱 **忘记释放** → 内存泄漏
- 😱 **重复释放** → 程序崩溃
- 😱 **使用已释放的内存** → 难以排查的 Bug

### ✨ GC 来拯救你

**垃圾回收（Garbage Collection）** 是 .NET 运行时（CLR）提供的**自动内存管理机制**。

```csharp
// C# 中你只需要这样
public void Example()
{
    var person = new Person { Name = "张三" };  // 创建对象
    // 使用对象...
}
// 方法结束后，GC 会自动回收不再使用的 person 对象
// 无需手动调用 delete 或 free！
```

### 🎯 GC 的职责

| 职责 | 说明 |
|------|------|
| 📦 **分配内存** | 为新创建的对象分配内存空间 |
| 👀 **跟踪对象** | 追踪哪些对象正在被使用 |
| 🗑️ **回收内存** | 释放不再使用的对象所占用的内存 |
| 🧩 **整理内存** | 压缩内存，减少碎片化 |

### 📝 小结

> GC 让你专注于业务逻辑，而不用操心内存管理。它是 .NET 的核心特性之一，让 C# 开发更安全、更高效。

---

## 2. 内存布局：堆与栈

### 📊 两种内存区域

.NET 程序运行时使用两种主要的内存区域：**栈（Stack）** 和 **堆（Heap）**。

```
┌─────────────────────────────────────────────────────────────┐
│                           栈 (Stack)                         │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────────┐                                    │
│  │ int x = 10          │  ← 值直接存储                       │
│  ├─────────────────────┤                                    │
│  │ Person person ──────│──┐ ← 引用（指针）存储               │
│  ├─────────────────────┤  │                                 │
│  │ string name ────────│──│─┐ ← 引用（指针）存储             │
│  └─────────────────────┘  │ │                               │
└───────────────────────────│─│───────────────────────────────┘
                            │ │
                            ▼ ▼
┌─────────────────────────────────────────────────────────────┐
│                           堆 (Heap)                          │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐   ┌─────────────────┐                  │
│  │ Person 对象      │   │ "Hello" 字符串  │                  │
│  │ Name = "张三"    │   │                 │                  │
│  └─────────────────┘   └─────────────────┘                  │
│                                                              │
│  由 GC 管理和回收                                             │
└─────────────────────────────────────────────────────────────┘
```

### 📚 栈（Stack）

**特点**：
- 🚀 存储**值类型变量**（如 `int`、`bool`、`struct`）和**方法调用信息**
- 📥 **后进先出（LIFO）** 结构
- ⚡ 由系统**自动分配和释放**，速度极快
- 📏 容量**有限**（默认约 1MB）

```csharp
public void StackExample()
{
    int x = 10;           // ← x 存储在栈上
    double y = 3.14;      // ← y 存储在栈上
    bool flag = true;     // ← flag 存储在栈上
    
    Point p = new Point(1, 2);  // 如果 Point 是 struct，则 p 存储在栈上
    
} // 方法结束时，这些栈内存自动释放

// 值类型
public struct Point
{
    public int X;
    public int Y;
}
```

### 🏔️ 堆（Heap）

**特点**：
- 📦 存储**引用类型对象**（如 `class`、`string`、`array`）
- 🧹 由 **GC 管理**生命周期
- 💾 容量**较大**，可动态扩展
- 🐢 分配和回收速度相对较慢

```csharp
public void HeapExample()
{
    // 引用类型 - 对象存储在堆上
    Person person = new Person();  // person 引用在栈上，Person 对象在堆上
    string name = "Hello";         // name 引用在栈上，字符串对象在堆上
    int[] numbers = new int[100];  // numbers 引用在栈上，数组在堆上
}

public class Person { public string Name { get; set; } }
```

### 🔄 值类型 vs 引用类型

| 特性 | 值类型 | 引用类型 |
|------|--------|----------|
| **存储位置** | 通常在栈上 | 堆上 |
| **包含** | 实际数据 | 指向数据的引用 |
| **示例** | `int`, `double`, `struct`, `enum` | `class`, `string`, `array`, `interface` |
| **赋值行为** | 复制值 | 复制引用（指向同一对象） |
| **默认值** | 0, false, '\0' 等 | null |

### 📝 小结

> 栈用于存储值类型和方法调用信息，由系统自动管理，速度快；堆用于存储引用类型对象，由 GC 管理，容量大。理解这两者的区别是掌握 GC 的基础。

---

## 3. 托管对象与非托管对象

### 🤖 托管对象（Managed Objects）

**定义**：由 CLR 管理的对象，GC 完全控制其内存分配和释放。

```csharp
// 所有这些都是托管对象，GC 自动管理
public class ManagedExample
{
    private List<int> _numbers = new List<int>();  // ✅ 托管对象
    private string _name = "Test";                  // ✅ 托管对象
    private byte[] _buffer = new byte[1024];       // ✅ 托管对象
}
```

**特点**：
- ✅ 自动分配内存
- ✅ 自动回收内存
- ✅ 无需手动释放
- ✅ 所有普通的 C# 对象都是托管对象

### 🔧 非托管对象（Unmanaged Objects）

**定义**：不受 CLR 管理的资源，通常是操作系统级别的资源。

**常见的非托管资源**：

| 资源类型 | 示例 |
|----------|------|
| 📁 文件句柄 | `FileStream` |
| 🗄️ 数据库连接 | `SqlConnection` |
| 🌐 网络套接字 | `Socket`, `HttpClient` |
| 🖼️ 图形资源 | `Bitmap`, `Graphics` |
| 🪟 窗口句柄 | Window Handle |
| 🔗 COM 对象 | Office Interop |

```csharp
// 这些类内部使用了非托管资源
FileStream fs = new FileStream("file.txt", FileMode.Open);  // 文件句柄
SqlConnection conn = new SqlConnection(connectionString);    // 数据库连接
HttpClient client = new HttpClient();                        // 网络资源
Bitmap bitmap = new Bitmap(100, 100);                        // GDI+ 对象
```

### ⚠️ 为什么非托管资源需要特别处理？

```csharp
// ❌ 危险代码示例 - 不释放非托管资源
public void BadExample()
{
    for (int i = 0; i < 1000; i++)
    {
        var fs = new FileStream($"file{i}.txt", FileMode.Open);
        // 忘记调用 fs.Close() 或 fs.Dispose()
    }
    // 结果：耗尽文件句柄，系统抛出异常！
}

// ✅ 正确做法
public void GoodExample()
{
    using (var fs = new FileStream("file.txt", FileMode.Open))
    {
        // 使用文件
    } // 自动调用 Dispose()，释放文件句柄
}
```

### 🏗️ 内存布局示意

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          内存布局示意                                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│   托管堆 (GC 管理)                     非托管内存 (操作系统管理)             │
│  ┌─────────────────────┐              ┌─────────────────────┐           │
│  │  FileStream 对象     │              │                     │          │
│  │  ┌───────────────┐  │  持有句柄     │   实际文件句柄        │          │
│  │  │ _handle ──────│──│─────────────▶│   (HANDLE)          │          │
│  │  │ _path         │  │              │                     │          │
│  │  │ _buffer[]     │  │              └─────────────────────┘          │
│  │  └───────────────┘  │                                               │
│  └─────────────────────┘                                               │
│         ▲                                                              │
│         │                                                              │
│    GC 只能回收这个托管对象本身                                             │
│    非托管资源需要手动释放！                                                │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 📝 小结

> 托管对象由 GC 完全管理，无需担心；非托管对象（如文件、数据库连接）需要手动释放，否则会导致资源泄漏。使用 `using` 语句是处理非托管资源的最佳方式。

---

## 4. GC 工作原理

### 🎯 分代回收机制（Generational Collection）

.NET GC 将托管堆分为**三代**，这基于一个重要假设：

> 💡 **新创建的对象生命周期通常较短，存活越久的对象越可能继续存活。**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                            托管堆 (Managed Heap)                         │
├────────────────────┬─────────────────────┬──────────────────────────────┤
│     第 0 代         │       第 1 代        │          第 2 代             │
│     (Gen 0)        │       (Gen 1)       │          (Gen 2)             │
├────────────────────┼─────────────────────┼──────────────────────────────┤
│ 🐣 新分配的对象     │ 🐥 从 Gen0 晋升      │ 🦅 从 Gen1 晋升               │
│ ⏱️ 生命周期最短     │ ⏱️ 中等生命周期      │ ⏱️ 生命周期最长                 │
│ 🔄 回收最频繁       │ 🔄 回收频率中等      │ 🔄 回收频率最低                │
│ 📏 约 256KB-4MB    │ 📏 约 0.5MB-4MB     │ 📏 可以很大                   │
└────────────────────┴─────────────────────┴──────────────────────────────┘
```

### 🔄 代的晋升流程

```csharp
public void GenerationDemo()
{
    // 1️⃣ 新对象分配到 Gen 0
    var obj = new MyClass();  // Gen 0
    
    Console.WriteLine($"Initial: Gen {GC.GetGeneration(obj)}");  // 输出: 0
    
    // 2️⃣ 触发 Gen 0 GC，存活对象晋升到 Gen 1
    GC.Collect(0);
    Console.WriteLine($"After Gen0 GC: Gen {GC.GetGeneration(obj)}");  // 输出: 1
    
    // 3️⃣ 触发 Gen 1 GC，存活对象晋升到 Gen 2
    GC.Collect(1);
    Console.WriteLine($"After Gen1 GC: Gen {GC.GetGeneration(obj)}");  // 输出: 2
    
    // 4️⃣ Gen 2 是最老的代，不会再晋升
}
```

### 🔍 GC 的三个阶段

#### 阶段1：标记（Mark）🏷️

从**根对象（GC Roots）** 开始，遍历所有可达对象并标记为"存活"。

**根对象包括**：
- 📍 栈上的局部变量
- 📍 静态变量
- 📍 CPU 寄存器中的引用
- 📍 终结器队列中的对象
- 📍 GC 句柄（GCHandle）

```
根对象 (GC Roots)
    │
    ├─→ Object A (✓ 标记为存活)
    │       │
    │       └─→ Object B (✓ 标记为存活)
    │               │
    │               └─→ Object C (✓ 标记为存活)
    │
    └─→ Object D (✓ 标记为存活)

Object E (✗ 不可达，将被回收)
Object F (✗ 不可达，将被回收)
```

#### 阶段2：清除（Sweep）🧹

回收未标记对象所占用的内存，将其返回给空闲列表。

#### 阶段3：压缩（Compact）📦

将存活对象移动到连续的内存空间，消除内存碎片。

```
压缩前（碎片化）：
┌───┬─────┬───┬─────┬───┬─────┐
│ A │ 空  │ B │ 空  │ C │ 空  │  ← 内存碎片化
└───┴─────┴───┴─────┴───┴─────┘

压缩后（连续）：
┌───┬───┬───┬───────────────────┐
│ A │ B │ C │      空闲空间      │  ← 连续内存
└───┴───┴───┴───────────────────┘
```

### ⏰ GC 触发条件

| 触发条件             | 说明                     |
| ---------------- | ---------------------- |
| 📦 **Gen 0 满**   | 最常见，新对象分配导致 Gen 0 空间不足 |
| 📦 **Gen 1/2 满** | 对象晋升导致空间不足             |
| 💾 **系统内存不足**    | 操作系统通知 CLR 内存紧张        |
| 🔨 **显式调用**      | `GC.Collect()`（不推荐）    |
| 🏁 **程序退出**      | CLR 关闭时清理              |

### 🚚 GC 会移动对象吗？

**是的！** GC 在压缩阶段会移动对象。

| 堆区域 | 是否移动 | 说明 |
|--------|----------|------|
| **Gen 0 / Gen 1** | ✅ 是 | 每次 GC 都会压缩 |
| **Gen 2** | ✅ 是（通常） | 完全 GC 时压缩 |
| **LOH** | ❌ 默认不移动 | 可手动触发压缩 |
| **POH** | ❌ 永不移动 | 固定对象，不移动 |

### 📝 小结

> GC 采用分代回收策略，新对象在 Gen 0，存活越久的对象越往高代晋升。GC 通过标记、清除、压缩三个阶段回收内存。理解这个机制有助于编写 GC 友好的代码。

---

## 5. 大对象堆（LOH）

### 📏 什么是 LOH？

**大对象堆（Large Object Heap）** 是专门存储大对象的堆区域。

**阈值**：**≥ 85,000 字节（约 83KB）**

```csharp
public void LOHDemo()
{
    // 📦 分配到小对象堆（SOH）
    byte[] small = new byte[84000];   // < 85,000 字节
    
    // 🐘 分配到大对象堆（LOH）
    byte[] large = new byte[85000];   // >= 85,000 字节
    
    // ⚠️ 数组也要考虑对象头
    // double[] 大约 10,624 个元素就会进入 LOH
    double[] largeDoubles = new double[10624];
}
```

### 🐘 LOH 的特点

| 特点 | 说明 |
|------|------|
| 🏷️ **属于 Gen 2** | LOH 在逻辑上属于第 2 代 |
| 🚫 **默认不压缩** | 不进行内存整理 |
| 🐢 **回收频率低** | 只在 Gen 2 GC 时回收 |
| 🧩 **容易碎片化** | 因为不压缩，容易产生内存碎片 |

### ⚠️ LOH 碎片化问题

```
频繁分配和释放不同大小的大对象会导致碎片化：

初始状态（连续）：
┌──────────────────────────────────────────┐
│                空闲空间                   │
└──────────────────────────────────────────┘

分配三个大对象：
┌────────┬────────────┬──────────┬─────────┐
│  100KB │   200KB    │  150KB   │  空闲   │
└────────┴────────────┴──────────┴─────────┘

释放中间的 200KB：
┌────────┬────────────┬──────────┬─────────┐
│  100KB │    空洞    │  150KB   │  空闲   │
└────────┴────────────┴──────────┴─────────┘

想分配 250KB？❌ 失败！虽然总空闲空间足够，但没有连续的 250KB！
```

### 💡 避免 LOH 碎片化的策略

#### 策略1：使用 ArrayPool 重用大数组 ♻️

```csharp
using System.Buffers;

public class ArrayPoolExample
{
    // ❌ 不好：每次都分配新数组
    public void BadPattern()
    {
        for (int i = 0; i < 1000; i++)
        {
            byte[] buffer = new byte[100_000];  // 每次都在 LOH 分配
            ProcessData(buffer);
        }
    }
    
    // ✅ 好：使用 ArrayPool 重用数组
    public void GoodPattern()
    {
        for (int i = 0; i < 1000; i++)
        {
            byte[] buffer = ArrayPool<byte>.Shared.Rent(100_000);
            try
            {
                ProcessData(buffer);
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer, clearArray: true);
            }
        }
    }
    
    private void ProcessData(byte[] buffer) { }
}
```

#### 策略2：分块处理，避免大数组 ✂️

```csharp
public class ChunkedProcessing
{
    // ❌ 不好：一次性读取大文件
    public async Task<byte[]> BadReadFile(string path)
    {
        return await File.ReadAllBytesAsync(path);  // 大文件会进入 LOH
    }
    
    // ✅ 好：分块读取和处理
    public async Task GoodProcessFile(string path, Func<byte[], int, Task> processor)
    {
        const int chunkSize = 81_920;  // 80KB，小于 LOH 阈值
        byte[] buffer = new byte[chunkSize];
        
        await using var fs = new FileStream(path, FileMode.Open);
        
        int bytesRead;
        while ((bytesRead = await fs.ReadAsync(buffer)) > 0)
        {
            await processor(buffer, bytesRead);
        }
    }
}
```

#### 策略3：手动压缩 LOH 🗜️

```csharp
using System.Runtime;

public void CompactLOH()
{
    // 设置 LOH 压缩模式
    GCSettings.LargeObjectHeapCompactionMode = 
        GCLargeObjectHeapCompactionMode.CompactOnce;
    
    // 触发 GC（压缩只在下一次完全 GC 时执行一次）
    GC.Collect();
    
    // 压缩后，模式自动重置为 Default
}
```

### 🔥 深入理解：List\<T\> 与 LOH 的关系

#### List.Clear() 能释放 LOH 内存吗？

**答案：❌ 不能！**

```csharp
public void ClearDemo()
{
    var list = new List<int>();
    for (int i = 0; i < 100000; i++)
        list.Add(i);
    
    Console.WriteLine($"Count: {list.Count}");      // 100000
    Console.WriteLine($"Capacity: {list.Capacity}"); // 131072
    
    // ❌ Clear() 只是把元素清空，Count 变成 0
    // 但底层数组的大小（Capacity）不变！
    list.Clear();
    
    Console.WriteLine($"Count: {list.Count}");      // 0
    Console.WriteLine($"Capacity: {list.Capacity}"); // 仍然是 131072！
    // LOH 内存没有释放！内部数组仍然占用内存
}
```

**`Clear()` 的实际行为**：

```
调用 Clear() 前：
┌─────────────────────────────────────────────────────┐
│  List<T> 对象                                        │
│  ┌─────────────────────────────────────────────────┐│
│  │ _items (内部数组) → [A][B][C]...[N] (LOH 上)    ││
│  │ _size = 100000                                  ││
│  └─────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────┘

调用 Clear() 后：
┌─────────────────────────────────────────────────────┐
│  List<T> 对象                                        │
│  ┌─────────────────────────────────────────────────┐│
│  │ _items (内部数组) → [null][null]...(LOH 上)     ││  ← 数组还在！
│  │ _size = 0                                       ││  ← 只是 Count 变成 0
│  └─────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────┘
```

#### ✅ 正确释放 List 内存的方法

**方法1：使用 `TrimExcess()` 释放多余容量**

```csharp
var list = new List<int>();
for (int i = 0; i < 100000; i++)
    list.Add(i);

list.Clear();
Console.WriteLine($"Capacity: {list.Capacity}"); // 131072 - 容量没变

list.TrimExcess();  // ✅ 释放多余容量
Console.WriteLine($"Capacity: {list.Capacity}"); // 0 - 旧数组可被 GC 回收
```

**方法2：设置 `Capacity = 0`**

```csharp
list.Clear();
list.Capacity = 0;  // ✅ 强制创建新的小数组，旧数组可被 GC
```

**方法3：重新 new 一个 List**

```csharp
list = new List<int>();  // ✅ 旧 List 和其内部数组变成垃圾
// ⚠️ 注意：旧数组不会立即释放，要等 GC
```

**方法4：使用 ArrayPool（最佳方案）**

```csharp
// 如果需要频繁创建大数组，使用 ArrayPool 根本不产生垃圾
byte[] buffer = ArrayPool<byte>.Shared.Rent(100000);
try
{
    // 使用 buffer
}
finally
{
    ArrayPool<byte>.Shared.Return(buffer);  // 归还，内存被重用
}
```

#### 📊 各种释放方法对比

| 方法 | 是否释放 LOH | 何时真正释放 | 推荐程度 |
|------|-------------|-------------|---------|
| `list.Clear()` | ❌ 不释放 | - | ⭐ |
| `list = new List<T>()` | ✅ 可释放 | 等待 GC | ⭐⭐ |
| `Clear()` + `TrimExcess()` | ✅ 可释放 | 等待 GC | ⭐⭐⭐ |
| `list.Capacity = 0` | ✅ 可释放 | 等待 GC | ⭐⭐⭐ |
| `list = null` + `GC.Collect(2)` | ✅ 释放 | 立即 | ⭐⭐（谨慎） |
| 使用 `ArrayPool<T>` | ✅ 重用 | 立即归还 | ⭐⭐⭐⭐⭐ |

#### ⏱️ LOH 上的垃圾何时被回收？

这取决于**数组的大小**：

| 数组大小 | 存储位置 | 回收时机 |
|----------|----------|----------|
| **< 85KB** | SOH (Gen 0/1/2) | 取决于当前代，下一次对应代的 GC 就可能回收 |
| **>= 85KB** | LOH (逻辑上 Gen 2) | **必须等 Full GC（Gen 2 GC）** ⚠️ |

**不同类型数组进入 LOH 的元素数量阈值**：

```csharp
// 阈值计算：85000 字节 / sizeof(T)

// byte[]    → 85000 / 1  = 85,000 个元素
// int[]     → 85000 / 4  = 21,250 个元素
// long[]    → 85000 / 8  = 10,625 个元素
// double[]  → 85000 / 8  = 10,625 个元素
// object[]  → 85000 / 8  = 10,625 个元素（64位系统）

// 所以 10 万元素的 List<T>：
// - List<byte> 10万 → 内部数组 100KB → LOH ⚠️
// - List<int> 10万  → 内部数组 400KB → LOH ⚠️
```

#### 🔄 List\<T\> 扩容与 LOH

当 `List<T>` 容量不足时会**扩容**，扩容策略是**容量翻倍**。

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    List<T> 扩容过程                                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  【阶段1】小数组阶段 - 都在 SOH                                          │
│                                                                         │
│  Add() → 容量不够 → 创建新数组(容量×2) → 复制元素 → 旧数组变垃圾          │
│                                                                         │
│  ┌────┐    ┌────────┐    ┌────────────────┐                            │
│  │ 4  │ →  │   8    │ →  │      16        │ →  ...  全部在 SOH         │
│  └────┘    └────────┘    └────────────────┘                            │
│                                                                         │
│  【阶段2】跨越 85KB 阈值的那一刻                                         │
│                                                                         │
│  假设当前：容量 16384 个 int = 64KB (在 SOH)                             │
│  需要扩容：新容量 32768 个 int = 128KB (>= 85KB!)                        │
│                                                                         │
│       SOH                              LOH                              │
│  ┌──────────────┐                ┌──────────────────────┐              │
│  │ 旧数组 64KB  │   ──复制──▶    │  新数组 128KB        │              │
│  │              │                │  (直接在 LOH 创建!)   │              │
│  └──────────────┘                └──────────────────────┘              │
│         ↓                                                              │
│       变成垃圾                                                          │
│                                                                         │
│  【阶段3】之后的扩容 - 都在 LOH                                          │
│                                                                         │
│  LOH 上的数组继续扩容时，新数组也在 LOH 上创建                            │
│  旧的 LOH 数组变成垃圾，必须等 Full GC 才能回收！                         │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

#### ❓ 对象会从 SOH 迁移到 LOH 吗？

**答案：❌ 永远不会！**

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        关于"迁移"的澄清                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ❌ 错误理解：                                                          │
│     "小数组在 SOH → 变大后迁移到 LOH"                                    │
│                                                                         │
│  ✅ 正确理解：                                                          │
│     1. 小数组在 SOH 创建                                                │
│     2. 扩容时，创建一个【全新的大数组】直接在 LOH                        │
│     3. 元素从旧数组【复制】到新数组                                      │
│     4. 旧数组变成垃圾，等待 GC 回收                                      │
│     5. List 的 _items 字段指向新数组                                    │
│                                                                         │
│  📍 GC 可能的移动：                                                     │
│     • SOH 内部：Gen 0 → Gen 1 → Gen 2（压缩时会移动）                   │
│     • LOH 内部：默认不移动（除非手动触发压缩）                           │
│     • SOH ↔ LOH：永远不会发生！对象一旦分配，位置固定                    │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 💡 避免扩容开销的最佳实践

```csharp
// ❌ 不好：多次扩容，产生大量垃圾数组
var list = new List<int>();
for (int i = 0; i < 100000; i++)
    list.Add(i);
// 扩容历程：4 → 8 → 16 → ... → 131072
// 产生了 17 个垃圾数组！

// ✅ 好：预分配容量，零扩容
var list = new List<int>(100000);
for (int i = 0; i < 100000; i++)
    list.Add(i);
// 只分配一次，无垃圾数组

// ✅ 也可以使用 EnsureCapacity（.NET 5+）
var list = new List<int>();
list.EnsureCapacity(100000);
```

### 📝 小结

> LOH 用于存储 ≥85KB 的大对象，默认不压缩，容易碎片化。通过 ArrayPool 重用数组、分块处理数据、必要时手动压缩，可以有效避免 LOH 相关的内存问题。
> 
> 🔑 **关于 List 和 LOH 的关键点**：
> - `Clear()` 不释放内存，要用 `TrimExcess()` 或 `Capacity = 0`
> - LOH 上的垃圾必须等 Full GC 才能回收（频率低！）
> - 对象不会在 SOH 和 LOH 之间迁移，扩容是创建新数组
> - 预分配容量是避免扩容开销的最简单方法
> - ArrayPool 是处理大数组的最佳方案

---

## 6. 固定对象堆（POH）

### 🆕 .NET 5+ 新特性

**固定对象堆（Pinned Object Heap）** 是 .NET 5 引入的新堆，专门存储需要**固定（pin）** 的对象。

### 🤔 为什么需要 POH？

当你需要将托管内存传递给本地代码（如 P/Invoke）时，需要"固定"对象，防止 GC 在操作期间移动它。

```csharp
// 传统方式：固定对象会影响 GC 效率
public unsafe void OldWay()
{
    byte[] buffer = new byte[1024];
    
    fixed (byte* ptr = buffer)
    {
        // 将 ptr 传递给本地代码
        // 在此期间，buffer 不会被 GC 移动
    }
    // 问题：固定的对象会阻碍 GC 压缩
}

// 新方式：使用 POH
public void NewWay()
{
    // 直接在 POH 上分配，永远不会被移动
    byte[] pinnedBuffer = GC.AllocateArray<byte>(1024, pinned: true);
    
    // 适合频繁与本地代码交互的场景
}
```

### ✨ POH 的特点

| 特点 | 说明 |
|------|------|
| 📌 **对象永久固定** | 在 POH 上分配的对象不会被移动 |
| 🔒 **不影响其他堆** | 与 SOH 分离，不影响正常 GC |
| 🌐 **适合 I/O 场景** | 网络、文件操作等需要固定缓冲区的场景 |
| 🧹 **仍被 GC 回收** | 虽然不移动，但不再使用时仍会被回收 |

### 📝 小结

> POH 是 .NET 5+ 的新特性，专门为需要固定的对象提供专用堆，避免影响正常 GC 的压缩操作，适合频繁与本地代码交互的场景。

---

## 7. 终结器（Finalizer）

### 🔔 什么是终结器？

终结器是一种**析构方法**，在对象被 GC 回收**之前**执行，用于清理非托管资源。

```csharp
public class FinalizerExample
{
    private IntPtr _nativeHandle;  // 非托管资源句柄
    
    public FinalizerExample()
    {
        _nativeHandle = AllocateNativeResource();
    }
    
    // 终结器（析构函数语法）
    ~FinalizerExample()
    {
        // 释放非托管资源
        if (_nativeHandle != IntPtr.Zero)
        {
            ReleaseNativeResource(_nativeHandle);
            _nativeHandle = IntPtr.Zero;
        }
    }
}
```

### ⚙️ 终结器的工作流程

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     终结器触发流程                                       │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  1️⃣ 创建带 Finalizer 的对象                                             │
│     └─▶ 对象同时添加到"终结队列"（Finalization Queue）                   │
│                                                                         │
│  2️⃣ 对象变得不可达，GC 标记阶段发现它                                   │
│     └─▶ 不立即回收！移到"待终结队列"（F-Reachable Queue）                │
│     └─▶ 对象被"复活"，晋升到下一代                                       │
│                                                                         │
│  3️⃣ 后台终结器线程（单线程）                                            │
│     └─▶ 执行 ~Finalizer() 方法                                          │
│     └─▶ ⚠️ 执行时间不确定！可能很久之后                                  │
│                                                                         │
│  4️⃣ 下一次 GC（该对象所在代的 GC）                                      │
│     └─▶ 对象终于被回收                                                  │
│                                                                         │
│  ⏱️ 总结：带终结器的对象至少需要 2 次 GC 才能回收！                       │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### ⚠️ 终结器的问题

| 问题 | 说明 |
|------|------|
| ⏱️ **执行时间不确定** | 不知道什么时候执行，可能在程序退出时才执行 |
| 🐌 **延长对象生命周期** | 至少晋升一代，需要两次 GC 才能回收 |
| 🔒 **单线程瓶颈** | 终结器线程是单线程，执行慢会阻塞其他对象 |
| 💥 **异常会导致崩溃** | 终结器中抛出异常会导致程序崩溃 |

### ❓ 什么时候使用终结器？

**仅当**：
1. ✅ 你的类**直接持有**非托管资源（如 `IntPtr`）
2. ✅ 作为**安全网**，确保资源最终被释放
3. ✅ 通常与 `IDisposable` 配合使用

**不需要终结器的情况**：
- ❌ 只持有托管资源
- ❌ 持有的是其他已实现 `IDisposable` 的对象
- ❌ 使用 `SafeHandle` 封装非托管资源

### 📝 小结

> 终结器是非托管资源的最后安全网，但执行时间不确定，会延长对象生命周期。应优先使用 `IDisposable` 模式及时释放资源，终结器只作为备用方案。

---

## 8. IDisposable 模式

### 🎯 为什么需要 IDisposable？

`IDisposable` 接口提供了一种**确定性释放资源**的方式，让你可以**立即**释放资源，而不是等待 GC。

### 📋 决策流程图

```
你的类是否直接持有资源？
        │
        ├─ 否 → ❌ 不需要 IDisposable 或 Finalizer
        │
        └─ 是 → 资源类型是什么？
                    │
                    ├─ 仅托管资源（如其他 IDisposable 对象）
                    │       │
                    │       └─ ✅ 只实现 IDisposable，不需要 Finalizer
                    │
                    └─ 非托管资源（IntPtr、句柄、本地内存等）
                            │
                            └─ ✅ 实现 IDisposable + Finalizer（作为安全网）
```

### 📝 场景1：仅持有托管资源（最常见）

```csharp
// 简化版 - 只有托管资源，不需要终结器
public class UserRepository : IDisposable
{
    private readonly SqlConnection _connection;
    private readonly SqlCommand _command;
    private bool _disposed = false;
    
    public UserRepository(string connectionString)
    {
        _connection = new SqlConnection(connectionString);
        _command = new SqlCommand { Connection = _connection };
    }
    
    public void Dispose()
    {
        if (_disposed) return;
        
        _command?.Dispose();
        _connection?.Dispose();
        
        _disposed = true;
        // ⚠️ 不需要 Finalizer！
    }
}
```

### 📝 场景2：直接持有非托管资源

```csharp
// 完整版 - 有非托管资源，需要终结器作为安全网
public class NativeResourceWrapper : IDisposable
{
    private IntPtr _nativeHandle;  // 非托管资源
    private Stream _managedStream; // 托管资源
    private bool _disposed = false;
    
    public NativeResourceWrapper()
    {
        _nativeHandle = AllocateNativeResource();
        _managedStream = new MemoryStream();
    }
    
    // 公共 Dispose 方法
    public void Dispose()
    {
        Dispose(disposing: true);
        GC.SuppressFinalize(this);  // 告诉 GC：不需要调用 Finalizer 了
    }
    
    // 核心释放逻辑
    protected virtual void Dispose(bool disposing)
    {
        if (_disposed) return;
        
        if (disposing)
        {
            // 释放托管资源
            _managedStream?.Dispose();
            _managedStream = null;
        }
        
        // 释放非托管资源（无论 disposing 是 true 还是 false）
        if (_nativeHandle != IntPtr.Zero)
        {
            FreeNativeResource(_nativeHandle);
            _nativeHandle = IntPtr.Zero;
        }
        
        _disposed = true;
    }
    
    // 终结器作为安全网
    ~NativeResourceWrapper()
    {
        Dispose(disposing: false);
    }
    
    private IntPtr AllocateNativeResource() => IntPtr.Zero;
    private void FreeNativeResource(IntPtr handle) { }
}
```

### 🔧 using 语句

```csharp
// 传统 using 语句
public void TraditionalUsing()
{
    using (var fs = new FileStream("file.txt", FileMode.Open))
    {
        // 使用文件流
    } // 自动调用 fs.Dispose()
}

// C# 8.0+ using 声明（推荐）
public void UsingDeclaration()
{
    using var fs = new FileStream("file.txt", FileMode.Open);
    // 使用文件流
} // 方法结束时自动调用 fs.Dispose()

// 多个资源
public void MultipleResources()
{
    using var conn = new SqlConnection(connectionString);
    using var cmd = new SqlCommand("SELECT * FROM Users", conn);
    using var reader = cmd.ExecuteReader();
    // 使用资源
} // 按相反顺序释放：reader → cmd → conn
```

### 🔄 IAsyncDisposable（异步释放）

```csharp
public class AsyncResource : IAsyncDisposable, IDisposable
{
    private Stream _stream;
    
    public async ValueTask DisposeAsync()
    {
        if (_stream != null)
        {
            await _stream.DisposeAsync();
            _stream = null;
        }
        GC.SuppressFinalize(this);
    }
    
    public void Dispose()
    {
        _stream?.Dispose();
        _stream = null;
        GC.SuppressFinalize(this);
    }
}

// 使用 await using
public async Task ProcessAsync()
{
    await using var resource = new AsyncResource();
    // 异步操作
} // 自动调用 DisposeAsync()
```

### 📊 决策总结表

| 你的类持有什么？ | IDisposable？ | Finalizer？ | 说明 |
|-----------------|---------------|-------------|------|
| 无资源 | ❌ | ❌ | 普通类，无需特殊处理 |
| 其他 IDisposable 对象 | ✅ | ❌ | 简化版 Dispose |
| SafeHandle | ✅ | ❌ | SafeHandle 内部已有 Finalizer |
| 直接持有非托管资源 | ✅ | ✅ | 完整 Dispose 模式 |

### 📝 小结

> `IDisposable` 是 .NET 中管理资源的标准模式。对于托管资源，只需实现简单的 `Dispose`；对于非托管资源，需要完整模式（IDisposable + Finalizer）。始终使用 `using` 语句确保资源被及时释放。

---

## 9. GC 模式配置

### ⚙️ 工作站模式 vs 服务器模式

| 特性 | 🖥️ 工作站模式 | 🖧 服务器模式 |
|------|--------------|--------------|
| **默认使用** | 桌面应用、单核服务器 | 多核服务器应用 |
| **GC 线程数** | 1 | 每个 CPU 核心一个 |
| **堆数量** | 1 | 每个 CPU 核心一个 |
| **GC 触发** | 较低阈值 | 较高阈值 |
| **内存使用** | 较少 | 较多 |
| **吞吐量** | 较低 | 较高 |
| **延迟** | 较低 | 较高（但有后台 GC） |

### 🔧 配置方法

**方法1：项目文件配置（推荐）**
```xml
<!-- .csproj 文件 -->
<PropertyGroup>
    <ServerGarbageCollection>true</ServerGarbageCollection>
    <ConcurrentGarbageCollection>true</ConcurrentGarbageCollection>
</PropertyGroup>
```

**方法2：runtimeconfig.json**
```json
{
    "runtimeOptions": {
        "configProperties": {
            "System.GC.Server": true,
            "System.GC.Concurrent": true
        }
    }
}
```

**方法3：环境变量**
```bash
# Windows PowerShell
$env:DOTNET_gcServer = "1"
$env:DOTNET_gcConcurrent = "1"

# Linux/macOS
export DOTNET_gcServer=1
export DOTNET_gcConcurrent=1
```

### ⏱️ GC 延迟模式

| 模式 | 说明 | 适用场景 |
|------|------|---------|
| `Batch` | 最大吞吐量，无后台 GC | 批处理任务 |
| `Interactive` | 默认模式，平衡延迟和吞吐量 | 大多数应用 |
| `LowLatency` | 最小化暂停时间 | 实时/游戏应用 |
| `SustainedLowLatency` | 长时间低延迟 | 金融交易系统 |
| `NoGCRegion` | 完全禁止 GC | 极端延迟敏感操作 |

```csharp
using System.Runtime;

// 临时切换到低延迟模式
public void LatencySensitiveOperation()
{
    var oldMode = GCSettings.LatencyMode;
    
    try
    {
        GCSettings.LatencyMode = GCLatencyMode.LowLatency;
        
        // 执行对延迟敏感的操作
        PerformCriticalOperation();
    }
    finally
    {
        GCSettings.LatencyMode = oldMode;
    }
}
```

### 📝 小结

> GC 提供工作站模式和服务器模式，可以根据应用场景选择。服务器模式适合高吞吐量场景，工作站模式适合低延迟场景。还可以通过延迟模式进一步调优。

---

## 10. IOC 容器与 GC

### 🎯 三种生命周期模式

```csharp
public void ConfigureServices(IServiceCollection services)
{
    // 🔄 Transient: 每次请求都创建新实例
    services.AddTransient<ITransientService, TransientService>();
    
    // 🔲 Scoped: 每个请求范围一个实例
    services.AddScoped<IScopedService, ScopedService>();
    
    // 🔷 Singleton: 整个应用生命周期一个实例
    services.AddSingleton<ISingletonService, SingletonService>();
}
```

### 🔍 GC 如何看待这些对象

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     IOC 对象的 GC 视角                                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  【🔄 Transient 对象】                                                  │
│  ┌──────────────────────────────────────────────────────────────┐      │
│  │  请求 ──▶ 创建实例 ──▶ 使用 ──▶ 请求结束 ──▶ GC 可回收 ✅     │      │
│  │                                                              │      │
│  │  📍 生命周期：短暂，通常在 Gen 0 被回收                       │      │
│  └──────────────────────────────────────────────────────────────┘      │
│                                                                         │
│  【🔲 Scoped 对象】                                                     │
│  ┌──────────────────────────────────────────────────────────────┐      │
│  │  请求开始 ──▶ 创建实例 ──▶ 整个请求期间使用                   │      │
│  │      │                                                       │      │
│  │      ▼                                                       │      │
│  │  IServiceScope 持有引用（GC 无法回收）                        │      │
│  │      │                                                       │      │
│  │      ▼                                                       │      │
│  │  请求结束 ──▶ Scope.Dispose() ──▶ GC 可回收 ✅               │      │
│  │                                                              │      │
│  │  📍 生命周期：中等，可能晋升到 Gen 1                          │      │
│  └──────────────────────────────────────────────────────────────┘      │
│                                                                         │
│  【🔷 Singleton 对象】                                                  │
│  ┌──────────────────────────────────────────────────────────────┐      │
│  │  应用启动 ──▶ 创建实例 ──▶ ServiceProvider 持有引用          │      │
│  │                               │                              │      │
│  │                               ▼                              │      │
│  │                          永远可达！GC 永不回收 ⚠️             │      │
│  │                               │                              │      │
│  │                               ▼                              │      │
│  │  应用关闭 ──▶ ServiceProvider.Dispose() ──▶ 进程结束         │      │
│  │                                                              │      │
│  │  📍 生命周期：整个应用期间，必然在 Gen 2                      │      │
│  └──────────────────────────────────────────────────────────────┘      │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 🗄️ 常见对象的生命周期建议

| 对象类型 | 推荐生命周期 | 原因 |
|----------|-------------|------|
| `DbContext` | 🔲 Scoped | 不是线程安全，变更跟踪器会增长 |
| `IConfiguration` | 🔷 Singleton | 配置应全局可用 |
| `ILogger` | 🔷 Singleton | 日志服务应全局可用 |
| `HttpClient` | 使用 `IHttpClientFactory` | 避免端口耗尽 |
| `IMemoryCache` | 🔷 Singleton | 缓存应全局共享 |

### ⚠️ 常见陷阱

#### 陷阱1：Singleton 中缓存无限增长

```csharp
// ❌ 危险：无限增长的缓存
public class BadCacheService
{
    private readonly Dictionary<string, object> _cache = new();
    
    public void Add(string key, object value)
    {
        _cache[key] = value;  // 永远不会被 GC 回收！
    }
}

// ✅ 安全：使用有过期机制的缓存
public class GoodCacheService
{
    private readonly IMemoryCache _cache;
    
    public void Add(string key, object value)
    {
        _cache.Set(key, value, new MemoryCacheEntryOptions
        {
            AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(10)
        });
    }
}
```

#### 陷阱2：Singleton 依赖 Scoped 服务

```csharp
// ❌ 错误：Singleton 持有 Scoped 依赖
public class BadSingletonService
{
    private readonly AppDbContext _context;  // ⚠️ 捕获的是启动时的实例
    
    public BadSingletonService(AppDbContext context)
    {
        _context = context;  // 这个 DbContext 永远不会被释放！
    }
}

// ✅ 正确：使用 IServiceScopeFactory
public class GoodSingletonService
{
    private readonly IServiceScopeFactory _scopeFactory;
    
    public GoodSingletonService(IServiceScopeFactory scopeFactory)
    {
        _scopeFactory = scopeFactory;
    }
    
    public async Task DoWork()
    {
        using var scope = _scopeFactory.CreateScope();
        var context = scope.ServiceProvider.GetRequiredService<AppDbContext>();
        // 使用 context，scope 结束时自动释放
    }
}
```

### 📝 小结

> IOC 容器的三种生命周期对 GC 有不同影响：Transient 短命易回收，Scoped 请求结束后可回收，Singleton 永不回收。注意避免 Singleton 中缓存无限增长和依赖 Scoped 服务的陷阱。

---

## 11. 最佳实践

### ✅ 减少内存分配

```csharp
// ❌ 不好：大量临时字符串
public string BadStringConcat(string[] items)
{
    string result = "";
    foreach (var item in items)
    {
        result += item;  // 每次都创建新字符串
    }
    return result;
}

// ✅ 好：使用 StringBuilder
public string GoodStringConcat(string[] items)
{
    var sb = new StringBuilder();
    foreach (var item in items)
    {
        sb.Append(item);
    }
    return sb.ToString();
}
```

### ✅ 使用对象池

```csharp
using System.Buffers;

public void UseArrayPool()
{
    byte[] buffer = ArrayPool<byte>.Shared.Rent(1024);
    try
    {
        ProcessBuffer(buffer);
    }
    finally
    {
        ArrayPool<byte>.Shared.Return(buffer);
    }
}
```

### ✅ 使用 Span<T> 避免分配

```csharp
// ❌ 不好：创建子数组副本
public byte[] BadSlice(byte[] data, int start, int length)
{
    byte[] result = new byte[length];
    Array.Copy(data, start, result, 0, length);
    return result;
}

// ✅ 好：使用 Span 创建视图，零分配
public ReadOnlySpan<byte> GoodSlice(byte[] data, int start, int length)
{
    return data.AsSpan(start, length);
}
```

### ✅ 避免装箱

```csharp
// ❌ 不好：发生装箱
int value = 42;
object boxed = value;  // 装箱：在堆上创建对象

// ❌ 不好：ArrayList 使用 object
var list = new ArrayList();
list.Add(1);  // 装箱

// ✅ 好：使用泛型集合
var list = new List<int>();
list.Add(1);  // 无装箱
```

### ✅ 正确处理事件订阅

```csharp
// ❌ 内存泄漏：事件未取消订阅
public class LeakySubscriber
{
    public LeakySubscriber(Publisher publisher)
    {
        publisher.DataChanged += OnDataChanged;
        // 如果 Publisher 生命周期比 Subscriber 长，Subscriber 永远不会被回收！
    }
}

// ✅ 安全：取消订阅
public class SafeSubscriber : IDisposable
{
    private readonly Publisher _publisher;
    
    public SafeSubscriber(Publisher publisher)
    {
        _publisher = publisher;
        _publisher.DataChanged += OnDataChanged;
    }
    
    public void Dispose()
    {
        _publisher.DataChanged -= OnDataChanged;
    }
}
```

### 📊 最佳实践清单

| 实践 | 说明 |
|------|------|
| ✅ 使用 `using` 和 `IDisposable` | 及时释放资源 |
| ✅ 使用 `ArrayPool<T>` | 重用数组，减少 LOH 分配 |
| ✅ 使用 `Span<T>` 和 `Memory<T>` | 零分配的内存操作 |
| ✅ 使用泛型集合 | 避免装箱 |
| ✅ 取消事件订阅 | 避免内存泄漏 |
| ✅ 使用有过期的缓存 | 避免无限增长 |
| ❌ 避免频繁调用 `GC.Collect()` | 让 GC 自己决定何时运行 |
| ❌ 避免频繁分配大对象 | 防止 LOH 碎片化 |

### 📝 小结

> 编写 GC 友好的代码：减少不必要的分配，重用对象，使用高效的数据结构，及时释放资源，正确管理事件订阅。这些实践能显著提升应用性能。

---

## 12. 诊断与监控

### 🔧 GC 相关 API

```csharp
public void ShowGCInfo()
{
    // 获取各代回收次数
    Console.WriteLine($"Gen 0 collections: {GC.CollectionCount(0)}");
    Console.WriteLine($"Gen 1 collections: {GC.CollectionCount(1)}");
    Console.WriteLine($"Gen 2 collections: {GC.CollectionCount(2)}");
    
    // 获取总内存使用
    Console.WriteLine($"Total memory: {GC.GetTotalMemory(false):N0} bytes");
    
    // 获取 GC 详细信息（.NET 5+）
    var gcInfo = GC.GetGCMemoryInfo();
    Console.WriteLine($"Heap size: {gcInfo.HeapSizeBytes:N0} bytes");
    Console.WriteLine($"Fragmented bytes: {gcInfo.FragmentedBytes:N0} bytes");
    
    // 获取对象所在的代
    var obj = new object();
    Console.WriteLine($"Object is in generation: {GC.GetGeneration(obj)}");
    
    // 检查 GC 模式
    Console.WriteLine($"Server GC: {GCSettings.IsServerGC}");
    Console.WriteLine($"Latency Mode: {GCSettings.LatencyMode}");
}
```

### 🛠️ 诊断工具

| 工具 | 用途 |
|------|------|
| **Visual Studio 诊断工具** | 内存分析、快照对比 |
| **dotnet-counters** | 实时监控 GC 计数器 |
| **dotnet-dump** | 收集和分析内存转储 |
| **dotnet-trace** | 收集 GC 事件跟踪 |
| **PerfView** | 深入分析 GC 和分配 |

```bash
# 监控 GC 计数器
dotnet-counters monitor --process-id <PID> System.Runtime

# 收集内存转储
dotnet-dump collect --process-id <PID>

# 分析转储
dotnet-dump analyze <dump-file>
```

### 📝 小结

> .NET 提供了丰富的 API 和工具来监控和诊断 GC。定期监控应用的内存使用情况，及时发现和解决潜在问题。

---

## 📚 总结

### 🎯 关键概念速查表

| 概念 | 说明 |
|------|------|
| **栈** | 值类型、方法调用信息，自动管理 |
| **堆** | 引用类型对象，GC 管理 |
| **托管对象** | CLR 自动管理的对象 |
| **非托管对象** | 需要手动释放的系统资源 |
| **分代回收** | Gen 0/1/2，越新越频繁回收 |
| **LOH** | 大对象堆，≥85KB 的对象 |
| **POH** | 固定对象堆（.NET 5+） |
| **Finalizer** | 终结器，GC 回收前的清理 |
| **IDisposable** | 及时释放资源的标准模式 |

### ✨ 黄金法则

1. ✅ **优先使用 `IDisposable` 和 `using`**，而非终结器
2. ✅ **减少不必要的内存分配**，使用对象池和 `Span<T>`
3. ✅ **避免大对象频繁分配**，防止 LOH 碎片化
4. ✅ **及时取消事件订阅**，防止内存泄漏
5. ✅ **使用泛型集合**，避免装箱
6. ❌ **不要频繁调用 `GC.Collect()`**
7. ❌ **不要在终结器中访问托管对象**

### 🎓 学习路径建议

1. **初学者**：理解堆/栈、托管/非托管、分代回收基本概念
2. **进阶**：掌握 IDisposable 模式、理解 LOH 和 Finalizer
3. **高级**：GC 调优、诊断工具使用、性能分析

---

> 📖 本文档持续更新，如有问题欢迎讨论！

